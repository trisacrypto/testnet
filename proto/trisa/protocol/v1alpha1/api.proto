syntax = "proto3";

package trisa.protocol.v1alpha1;
option go_package = "github.com/trisacrypto/testnet/pkg/trisa/protocol/v1alpha1";

import "google/protobuf/any.proto";
import "trisa/protocol/v1alpha1/errors.proto";


// The TRISANetwork service defines the peer-to-peer interactions between VASPs that are
// necessary to conduct compliance information exchanges. All TRISA members must
// implement all services described by the TRISA protocol to ensure that exchanges are
// conducted correctly and securely. The primary RPCs are Transfer and TransactionStream
// which allow VASPs to exchange compliance information before conducting a virtual
// asset transaction. The other RPCs facilitate Transfers, allowing address
// confirmations prior to a transfer and public key exchange so that transaction
// envelopes can be encrypted and signed.
service TRISANetwork {
    // To conduct an information exchange prior to a virtual asset transaction, an
    // originating VASP will send an encrypted transaction envelope to the beneficiary
    // VASP containing a unique ID for the transaction, the encrypted transaction bundle,
    // and metadata associated with the transaction cipher. In response, the beneficiary
    // will validate the transaction request, then return the beneficiary's transaction
    // information using the same unique transaction ID. The TRISANetwork provides both
    // a unary RPC for simple, single transactions and a transaction stream for high
    // throughput transaction workloads.
    rpc Transfer(Transaction) returns (Transaction) {}
    rpc TransactionStream(stream Transaction) returns (stream Transaction) {}

    // Address confirmation allows an originator VASP to establish that a beneficiary
    // VASP has control of a crypto wallet address, prior to sending transaction
    // information with sensitive PII data.
    rpc ConfirmAddress(Address) returns (AddressConfirmation) {}

    // The encrypted transaction envelope uses asymmetric (public/private) encryption to
    // exchange a symmetric key and signature for the transaction blob. To facilitate
    // transaction signatures, VASPs must be able to exchange public signing keys if
    // they have not already obtained them from the directory service.
    rpc KeyExchange(SigningKey) returns (SigningKey) {}
}

// The TRISADiscovery service assists with establishing mTLS connections at a
// beneficiary VASP. All TRISANetwork RPCs must be over a secure mTLS connection,
// however if the beneficiary VASP does not recognize the originator VASP, e.g. it does
// not have the originator VASP's client keys cached, it will reject the request. The
// TRISADiscovery service allows the originator to make a non-mTLS connection request
// that the beneficiary perform a directory service lookup to verify the originator's
// identity and TRISA credentials. Once complete, the mTLS connection can be established.
//
// TODO: This presumes that we cannot intercept mTLS failures on the server side and
// attempt a Directory Service lookup (which is not the default behavior). Additionally,
// while this is a simpler implementation, it will require the server to listen on two
// different ports, which would require the Directory Service to store two endpoints.
service TRISADiscovery {
    rpc Handshake(VASPLookup) returns (Connection) {}
}

// The TRISAHealth service is optional but highly recommended for VASP members to
// implement. The Status endpoint allows the TRISA Directory Service to perform health
// checks with VASP's TrISA Node and report the service conditions of the TRISA network.
// Because a down TRISA node will prevent travel rule compliant virtual asset
// transactions, the health service is intended to quickly identify network problems and
// notify members as quickly as possible.
service TRISAHealth {
    rpc Status(HealthCheck) returns (ServiceState) {}
}


message Transaction {
    // The transaction identifier generated by the sender. Any response
    // to a transaction request needs to carry the same identifier.
    string id = 1;

    // If an error occurred during the processing of the transaction.
    Error error = 2;

    // Encrypted TransactionData
    bytes transaction = 3;

    // Encryption key used to encrypt the transaction blob. This key itself
    // is encrypted using the public key of the receiver.
    bytes encryption_key = 4;

    // The encryption algorithm used to encrypt the transaction blob.
    string encryption_algorithm = 5;

    // HMAC signature calculated from encrypted transaction blob.
    bytes hmac = 6;

    // The HMAC secret used to calculate the HMAC signature. This secret
    // itself is encrypted using the public key of the receiver.
    bytes hmac_secret = 7;

    // The algorithm used to calculate the HMAC signature.
    string hmac_algorithm = 8;
}

message TransactionData {
    // Identity contains any valid identity structure.
    google.protobuf.Any identity = 1;

    // Data contains the network specific data.
    google.protobuf.Any data = 2;
}

// TODO: specify the address confirmation protocol.
message Address {}
message AddressConfirmation {}

// SigningKey provides metadata for decoding a PEM encoded PKIX public key for RSA
// encryption and transaction signing. The SigningKey is a lightweight version of the
// Certificate information stored in the Directory Service.
message SigningKey {
    // x.509 metadata information for ease of reference without parsing the key.
    int64 version = 1;
    bytes signature = 2;
    string signature_algorithm = 3;
    string public_key_algorithm = 4;

    // Validity information
    string not_before = 8;
    string not_after = 9;
    bool revoked = 10;

    // The PEM encoded public key to PKIX, ASN.1 DER form without the trust chain.
    bytes data = 11;
}

// VASPLookup provides details about the originator VASP to facilitate a lookup in the
// TRISA Directory Service. If the originator claims are verified by the Directory
// Service, the beneficiary VASP responds with a connection endpoint to establish an
// mTLS connection. The originator VASP must specify either the VASP id or the common
// name. Optionally, the VASP can specify the registered directory, but the beneficiary
// VASP does not have to respect this field.
message VASPLookup {
    // Unique identifier generated by the directory service, most common lookup field.
    string id = 1;

    // The common name of the certificate, e.g. the domain name of the TRISA endpoint.
    // either the ID or the common_name must be supplied to the directory service.
    string common_name = 2;

    // The URL of the directory that registered the VASP, optional.
    string registered_directory = 3;
}

// A Connection response to a VASPLookup can either be a rejection error (e.g.
// out-of-network) or a redirect to the TRISA network endpoint along with Beneficiary
// VASP lookup information.
message Connection {
    // Reject handshakes with UNTRUSTED or OUT_OF_NETWORK errors.
    Error error = 1;

    // The endpoint to establish an mTLS connection on, e.g. the address of the
    // TRISANetwork service.
    string trisa_endpoint = 2;

    // Reciprocate VASPLookup information so that the originator can verify the
    // beneficiary in the directory service.
    VASPLookup lookup = 3;
}


message HealthCheck {
    // The number of failed health checks that proceeded the current check.
    uint32 attempts = 1;

    // The timestamp of the last health check, successful or otherwise.
    string last_checked_at = 2;
}

message ServiceState {
    enum Status {
        UNKNOWN = 0;
        HEALTHY = 1;
        UNHEALTHY = 2;
        DANGER = 3;
        OFFLINE = 4;
        MAINTENANCE = 5;
    }

    // Could not return a service state to the requestor.
    Error error = 1;

    // Current service status as defined by the recieving system. The system is obliged
    // to respond with the closest matching status in a best-effort fashion. Alerts will
    // be triggered on service status changes if the system does not respond and the
    // previous system state was not unknown.
    Status status = 2;

    // Suggest to the directory service when to check the health status again.
    string not_before = 3;
    string not_after = 4;
}