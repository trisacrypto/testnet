// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ivms101.proto

package ivms101

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Person struct {
	// Types that are valid to be assigned to Person:
	//	*Person_NaturalPerson
	//	*Person_LegalPerson
	Person               isPerson_Person `protobuf_oneof:"person"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}
func (*Person) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{0}
}

func (m *Person) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Person.Unmarshal(m, b)
}
func (m *Person) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Person.Marshal(b, m, deterministic)
}
func (m *Person) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Person.Merge(m, src)
}
func (m *Person) XXX_Size() int {
	return xxx_messageInfo_Person.Size(m)
}
func (m *Person) XXX_DiscardUnknown() {
	xxx_messageInfo_Person.DiscardUnknown(m)
}

var xxx_messageInfo_Person proto.InternalMessageInfo

type isPerson_Person interface {
	isPerson_Person()
}

type Person_NaturalPerson struct {
	NaturalPerson *NaturalPerson `protobuf:"bytes,1,opt,name=natural_person,json=naturalPerson,proto3,oneof"`
}

type Person_LegalPerson struct {
	LegalPerson *LegalPerson `protobuf:"bytes,2,opt,name=legal_person,json=legalPerson,proto3,oneof"`
}

func (*Person_NaturalPerson) isPerson_Person() {}

func (*Person_LegalPerson) isPerson_Person() {}

func (m *Person) GetPerson() isPerson_Person {
	if m != nil {
		return m.Person
	}
	return nil
}

func (m *Person) GetNaturalPerson() *NaturalPerson {
	if x, ok := m.GetPerson().(*Person_NaturalPerson); ok {
		return x.NaturalPerson
	}
	return nil
}

func (m *Person) GetLegalPerson() *LegalPerson {
	if x, ok := m.GetPerson().(*Person_LegalPerson); ok {
		return x.LegalPerson
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Person) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Person_OneofMarshaler, _Person_OneofUnmarshaler, _Person_OneofSizer, []interface{}{
		(*Person_NaturalPerson)(nil),
		(*Person_LegalPerson)(nil),
	}
}

func _Person_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Person)
	// person
	switch x := m.Person.(type) {
	case *Person_NaturalPerson:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NaturalPerson); err != nil {
			return err
		}
	case *Person_LegalPerson:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LegalPerson); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Person.Person has unexpected type %T", x)
	}
	return nil
}

func _Person_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Person)
	switch tag {
	case 1: // person.natural_person
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NaturalPerson)
		err := b.DecodeMessage(msg)
		m.Person = &Person_NaturalPerson{msg}
		return true, err
	case 2: // person.legal_person
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LegalPerson)
		err := b.DecodeMessage(msg)
		m.Person = &Person_LegalPerson{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Person_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Person)
	// person
	switch x := m.Person.(type) {
	case *Person_NaturalPerson:
		s := proto.Size(x.NaturalPerson)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Person_LegalPerson:
		s := proto.Size(x.LegalPerson)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Definition: refers to a uniquely distinguishable individual; one single person
type NaturalPerson struct {
	// Definition: the distinct words used as identification for an individual.
	// Required
	Name *NaturalPersonName `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Definition: the particulars of a location at which a person may be communicated with.
	// Zero or More
	GeographicAddresses []*Address `protobuf:"bytes,2,rep,name=geographic_addresses,json=geographicAddresses,proto3" json:"geographic_addresses,omitempty"`
	// Definition: a distinct identifier used by governments of countries to uniquely
	// identify a natural or legal person.
	// Optional
	NationalIdentification *NationalIdentification `protobuf:"bytes,3,opt,name=national_identification,json=nationalIdentification,proto3" json:"national_identification,omitempty"`
	// Definition: a distinct identifier that uniquely identifies the person to the
	// institution in context.
	// Datatype: “Max50Text”
	// Optional
	CustomerIdentification string `protobuf:"bytes,4,opt,name=customer_identification,json=customerIdentification,proto3" json:"customer_identification,omitempty"`
	// Definition: date and place of birth of a person.
	// Optional
	DateAndPlaceOfBirth *DateAndPlaceOfBirth `protobuf:"bytes,5,opt,name=date_and_place_of_birth,json=dateAndPlaceOfBirth,proto3" json:"date_and_place_of_birth,omitempty"`
	// Definition: country in which a person resides (the place of a person's home).
	// The value used for the field country must be present on the ISO-3166-1 alpha-2
	// codes or the value XX.
	// Datatype: “CountryCode”
	// Optional
	CountryOfResidence   string   `protobuf:"bytes,6,opt,name=country_of_residence,json=countryOfResidence,proto3" json:"country_of_residence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaturalPerson) Reset()         { *m = NaturalPerson{} }
func (m *NaturalPerson) String() string { return proto.CompactTextString(m) }
func (*NaturalPerson) ProtoMessage()    {}
func (*NaturalPerson) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{1}
}

func (m *NaturalPerson) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NaturalPerson.Unmarshal(m, b)
}
func (m *NaturalPerson) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NaturalPerson.Marshal(b, m, deterministic)
}
func (m *NaturalPerson) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaturalPerson.Merge(m, src)
}
func (m *NaturalPerson) XXX_Size() int {
	return xxx_messageInfo_NaturalPerson.Size(m)
}
func (m *NaturalPerson) XXX_DiscardUnknown() {
	xxx_messageInfo_NaturalPerson.DiscardUnknown(m)
}

var xxx_messageInfo_NaturalPerson proto.InternalMessageInfo

func (m *NaturalPerson) GetName() *NaturalPersonName {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NaturalPerson) GetGeographicAddresses() []*Address {
	if m != nil {
		return m.GeographicAddresses
	}
	return nil
}

func (m *NaturalPerson) GetNationalIdentification() *NationalIdentification {
	if m != nil {
		return m.NationalIdentification
	}
	return nil
}

func (m *NaturalPerson) GetCustomerIdentification() string {
	if m != nil {
		return m.CustomerIdentification
	}
	return ""
}

func (m *NaturalPerson) GetDateAndPlaceOfBirth() *DateAndPlaceOfBirth {
	if m != nil {
		return m.DateAndPlaceOfBirth
	}
	return nil
}

func (m *NaturalPerson) GetCountryOfResidence() string {
	if m != nil {
		return m.CountryOfResidence
	}
	return ""
}

type NaturalPersonName struct {
	// At least one occurrence of naturalPersonNameID must have the value ‘LEGL’
	// specified in the element naturalPersonNameIdentifierType.
	// Definition: full name separated into primary and secondary identifier.
	// One or more
	NameIdentifiers []*NaturalPersonNameId `protobuf:"bytes,1,rep,name=name_identifiers,json=nameIdentifiers,proto3" json:"name_identifiers,omitempty"`
	// Definition: full name separated into primary and secondary identifier using
	// local characters.
	// Zero or more
	LocalNameIdentifiers []*LocalNaturalPersonNameId `protobuf:"bytes,2,rep,name=local_name_identifiers,json=localNameIdentifiers,proto3" json:"local_name_identifiers,omitempty"`
	// Definition: Alternate representation of a name that corresponds to the manner
	// the name is pronounced.
	// Zero or more
	PhoneticNameIdentifiers []*LocalNaturalPersonNameId `protobuf:"bytes,3,rep,name=phonetic_name_identifiers,json=phoneticNameIdentifiers,proto3" json:"phonetic_name_identifiers,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                    `json:"-"`
	XXX_unrecognized        []byte                      `json:"-"`
	XXX_sizecache           int32                       `json:"-"`
}

func (m *NaturalPersonName) Reset()         { *m = NaturalPersonName{} }
func (m *NaturalPersonName) String() string { return proto.CompactTextString(m) }
func (*NaturalPersonName) ProtoMessage()    {}
func (*NaturalPersonName) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{2}
}

func (m *NaturalPersonName) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NaturalPersonName.Unmarshal(m, b)
}
func (m *NaturalPersonName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NaturalPersonName.Marshal(b, m, deterministic)
}
func (m *NaturalPersonName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaturalPersonName.Merge(m, src)
}
func (m *NaturalPersonName) XXX_Size() int {
	return xxx_messageInfo_NaturalPersonName.Size(m)
}
func (m *NaturalPersonName) XXX_DiscardUnknown() {
	xxx_messageInfo_NaturalPersonName.DiscardUnknown(m)
}

var xxx_messageInfo_NaturalPersonName proto.InternalMessageInfo

func (m *NaturalPersonName) GetNameIdentifiers() []*NaturalPersonNameId {
	if m != nil {
		return m.NameIdentifiers
	}
	return nil
}

func (m *NaturalPersonName) GetLocalNameIdentifiers() []*LocalNaturalPersonNameId {
	if m != nil {
		return m.LocalNameIdentifiers
	}
	return nil
}

func (m *NaturalPersonName) GetPhoneticNameIdentifiers() []*LocalNaturalPersonNameId {
	if m != nil {
		return m.PhoneticNameIdentifiers
	}
	return nil
}

type NaturalPersonNameId struct {
	// Definition: This may be the family name, the maiden name or the married name,
	// the main name, the surname, and in some cases, the entire name where the natural
	// person’s name cannot be divided into two parts, or where the sender is unable to
	// divide the natural person’s name into two parts.
	// Datatype: “Max100Text”
	// Required
	PrimaryIdentifier string `protobuf:"bytes,1,opt,name=primary_identifier,json=primaryIdentifier,proto3" json:"primary_identifier,omitempty"`
	// Definition: These may be the forenames, familiar names, given names, initials,
	// prefixes, suffixes or Roman numerals (where considered to be legally part of the
	// name) or any other secondary names.
	// Datatype: “Max100Text”
	// Optional
	SecondaryIdentifier string `protobuf:"bytes,2,opt,name=secondary_identifier,json=secondaryIdentifier,proto3" json:"secondary_identifier,omitempty"`
	// Definition: The nature of the name specified.
	// Required
	NameIdentifierType   NaturalPersonNameTypeCode `protobuf:"varint,3,opt,name=name_identifier_type,json=nameIdentifierType,proto3,enum=ivms101.NaturalPersonNameTypeCode" json:"name_identifier_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *NaturalPersonNameId) Reset()         { *m = NaturalPersonNameId{} }
func (m *NaturalPersonNameId) String() string { return proto.CompactTextString(m) }
func (*NaturalPersonNameId) ProtoMessage()    {}
func (*NaturalPersonNameId) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{3}
}

func (m *NaturalPersonNameId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NaturalPersonNameId.Unmarshal(m, b)
}
func (m *NaturalPersonNameId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NaturalPersonNameId.Marshal(b, m, deterministic)
}
func (m *NaturalPersonNameId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaturalPersonNameId.Merge(m, src)
}
func (m *NaturalPersonNameId) XXX_Size() int {
	return xxx_messageInfo_NaturalPersonNameId.Size(m)
}
func (m *NaturalPersonNameId) XXX_DiscardUnknown() {
	xxx_messageInfo_NaturalPersonNameId.DiscardUnknown(m)
}

var xxx_messageInfo_NaturalPersonNameId proto.InternalMessageInfo

func (m *NaturalPersonNameId) GetPrimaryIdentifier() string {
	if m != nil {
		return m.PrimaryIdentifier
	}
	return ""
}

func (m *NaturalPersonNameId) GetSecondaryIdentifier() string {
	if m != nil {
		return m.SecondaryIdentifier
	}
	return ""
}

func (m *NaturalPersonNameId) GetNameIdentifierType() NaturalPersonNameTypeCode {
	if m != nil {
		return m.NameIdentifierType
	}
	return NaturalPersonNameTypeCode_NATURAL_PERSON_NAME_TYPE_CODE_ALIA
}

type LocalNaturalPersonNameId struct {
	// Definition: This may be the family name, the maiden name or the married name,
	// the main name, the surname, and in some cases, the entire name where the natural
	// person’s name cannot be divided into two parts, or where the sender is unable to
	// divide the natural person’s name into two parts.
	// Datatype: “LocalMax100Text”
	// Required
	PrimaryIdentifier string `protobuf:"bytes,1,opt,name=primary_identifier,json=primaryIdentifier,proto3" json:"primary_identifier,omitempty"`
	// Definition: These may be the forenames, familiar names, given names, initials,
	// prefixes, suffixes or Roman numerals (where considered to be legally part of
	// the name) or any other secondary names.
	// Datatype: “LocalMax100Text”
	// Optional
	SecondaryIdentifier string `protobuf:"bytes,2,opt,name=secondary_identifier,json=secondaryIdentifier,proto3" json:"secondary_identifier,omitempty"`
	// Definition: The nature of the name specified.
	// Required
	NameIdentifierType   NaturalPersonNameTypeCode `protobuf:"varint,3,opt,name=name_identifier_type,json=nameIdentifierType,proto3,enum=ivms101.NaturalPersonNameTypeCode" json:"name_identifier_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *LocalNaturalPersonNameId) Reset()         { *m = LocalNaturalPersonNameId{} }
func (m *LocalNaturalPersonNameId) String() string { return proto.CompactTextString(m) }
func (*LocalNaturalPersonNameId) ProtoMessage()    {}
func (*LocalNaturalPersonNameId) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{4}
}

func (m *LocalNaturalPersonNameId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocalNaturalPersonNameId.Unmarshal(m, b)
}
func (m *LocalNaturalPersonNameId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocalNaturalPersonNameId.Marshal(b, m, deterministic)
}
func (m *LocalNaturalPersonNameId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalNaturalPersonNameId.Merge(m, src)
}
func (m *LocalNaturalPersonNameId) XXX_Size() int {
	return xxx_messageInfo_LocalNaturalPersonNameId.Size(m)
}
func (m *LocalNaturalPersonNameId) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalNaturalPersonNameId.DiscardUnknown(m)
}

var xxx_messageInfo_LocalNaturalPersonNameId proto.InternalMessageInfo

func (m *LocalNaturalPersonNameId) GetPrimaryIdentifier() string {
	if m != nil {
		return m.PrimaryIdentifier
	}
	return ""
}

func (m *LocalNaturalPersonNameId) GetSecondaryIdentifier() string {
	if m != nil {
		return m.SecondaryIdentifier
	}
	return ""
}

func (m *LocalNaturalPersonNameId) GetNameIdentifierType() NaturalPersonNameTypeCode {
	if m != nil {
		return m.NameIdentifierType
	}
	return NaturalPersonNameTypeCode_NATURAL_PERSON_NAME_TYPE_CODE_ALIA
}

// Constraint: ValidAddress
// There must be at least one occurrence of the element addressLine or (streetName and
// buildingName and/or buildingNumber).
type Address struct {
	// Definition: Identifies the nature of the address.
	// Required
	AddressType AddressTypeCode `protobuf:"varint,1,opt,name=address_type,json=addressType,proto3,enum=ivms101.AddressTypeCode" json:"address_type,omitempty"`
	// Definition: Identification of a division of a large organisation or building.
	// Datatype: “Max50Text”
	// Optional
	Department string `protobuf:"bytes,2,opt,name=department,proto3" json:"department,omitempty"`
	// Definition: Identification of a sub-division of a large organisation or building.
	// Datatype: “Max70Text”
	// Optional
	SubDepartment string `protobuf:"bytes,3,opt,name=sub_department,json=subDepartment,proto3" json:"sub_department,omitempty"`
	// Definition: Name of a street or thoroughfare.
	// Datatype: “Max70Text”
	// Optional
	StreetName string `protobuf:"bytes,4,opt,name=street_name,json=streetName,proto3" json:"street_name,omitempty"`
	// Definition: Number that identifies the position of a building on a street.
	// Datatype: “Max16Text”
	// Optional
	BuildingNumber string `protobuf:"bytes,5,opt,name=building_number,json=buildingNumber,proto3" json:"building_number,omitempty"`
	// Definition: Name of the building or house.
	// Datatype: “Max35Text”
	// Optional
	BuildingName string `protobuf:"bytes,6,opt,name=building_name,json=buildingName,proto3" json:"building_name,omitempty"`
	// Definition: Floor or storey within a building.
	// Datatype: “Max70Text”
	// Optional
	Floor string `protobuf:"bytes,7,opt,name=floor,proto3" json:"floor,omitempty"`
	// Definition: Numbered box in a post office, assigned to a person or organisation,
	// where letters are kept until called for.
	// Datatype: “Max16Text”
	// Optional
	PostBox string `protobuf:"bytes,8,opt,name=post_box,json=postBox,proto3" json:"post_box,omitempty"`
	// Definition: Building room number.
	// Datatype: “Max70Text”
	// Optional
	Room string `protobuf:"bytes,9,opt,name=room,proto3" json:"room,omitempty"`
	// Definition: Identifier consisting of a group of letters and/or numbers that is
	// added to a postal address to assist the sorting of mail.
	// Datatype: “Max16Text”
	// Optional
	PostCode string `protobuf:"bytes,10,opt,name=post_code,json=postCode,proto3" json:"post_code,omitempty"`
	// Definition: Name of a built-up area, with defined boundaries and a local government.
	// Datatype: “Max35Text”
	// Optional
	TownName string `protobuf:"bytes,11,opt,name=town_name,json=townName,proto3" json:"town_name,omitempty"`
	// Definition: Specific location name within the town.
	// Datatype: “Max35Text”
	// Optional
	TownLocationName string `protobuf:"bytes,12,opt,name=town_location_name,json=townLocationName,proto3" json:"town_location_name,omitempty"`
	// Definition: Identifies a subdivision within a country subdivision.
	// Datatype: “Max35Text”
	// Optional
	DistrictName string `protobuf:"bytes,13,opt,name=district_name,json=districtName,proto3" json:"district_name,omitempty"`
	// Definition: Identifies a subdivision of a country for example, state, region,
	// province, départment or county.
	// Datatype: “Max35Text”
	// Optional
	CountrySubDivision string `protobuf:"bytes,14,opt,name=country_sub_division,json=countrySubDivision,proto3" json:"country_sub_division,omitempty"`
	// Definition: Information that locates and identifies a specific address, as
	// defined by postal services, presented in free format text.
	// Datatype: “Max70Text”
	// Zero to Seven
	AddressLine []string `protobuf:"bytes,15,rep,name=address_line,json=addressLine,proto3" json:"address_line,omitempty"`
	// Constraint: The value used for the field country must be present on the
	// ISO-3166-1 alpha-2 codes or the value XX.
	// Datatype: “CountryCode”
	// Required
	Country              string   `protobuf:"bytes,16,opt,name=country,proto3" json:"country,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{5}
}

func (m *Address) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Address.Unmarshal(m, b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Address.Marshal(b, m, deterministic)
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return xxx_messageInfo_Address.Size(m)
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetAddressType() AddressTypeCode {
	if m != nil {
		return m.AddressType
	}
	return AddressTypeCode_ADDRESS_TYPE_CODE_HOME
}

func (m *Address) GetDepartment() string {
	if m != nil {
		return m.Department
	}
	return ""
}

func (m *Address) GetSubDepartment() string {
	if m != nil {
		return m.SubDepartment
	}
	return ""
}

func (m *Address) GetStreetName() string {
	if m != nil {
		return m.StreetName
	}
	return ""
}

func (m *Address) GetBuildingNumber() string {
	if m != nil {
		return m.BuildingNumber
	}
	return ""
}

func (m *Address) GetBuildingName() string {
	if m != nil {
		return m.BuildingName
	}
	return ""
}

func (m *Address) GetFloor() string {
	if m != nil {
		return m.Floor
	}
	return ""
}

func (m *Address) GetPostBox() string {
	if m != nil {
		return m.PostBox
	}
	return ""
}

func (m *Address) GetRoom() string {
	if m != nil {
		return m.Room
	}
	return ""
}

func (m *Address) GetPostCode() string {
	if m != nil {
		return m.PostCode
	}
	return ""
}

func (m *Address) GetTownName() string {
	if m != nil {
		return m.TownName
	}
	return ""
}

func (m *Address) GetTownLocationName() string {
	if m != nil {
		return m.TownLocationName
	}
	return ""
}

func (m *Address) GetDistrictName() string {
	if m != nil {
		return m.DistrictName
	}
	return ""
}

func (m *Address) GetCountrySubDivision() string {
	if m != nil {
		return m.CountrySubDivision
	}
	return ""
}

func (m *Address) GetAddressLine() []string {
	if m != nil {
		return m.AddressLine
	}
	return nil
}

func (m *Address) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

// Constraint: DateInPast
// If dateOfBirth is specified, the date specified must be a historic date (i.e. a date
// prior to the current date)
type DateAndPlaceOfBirth struct {
	// Definition: Date on which a person is born.
	// Definition: A point in time, represented as a day within the calendar year.
	// Compliant with ISO 8601.
	// Type: Text
	// Format: YYYY-MM-DD
	// Regex: ^([0-9]{4})-([0-9]{2})-([0-9]{2})$
	// Required
	DateOfBirth string `protobuf:"bytes,1,opt,name=date_of_birth,json=dateOfBirth,proto3" json:"date_of_birth,omitempty"`
	// Definition: The town and/or the city and/or the suburb and/or the country
	// subdivision and/or the country where the person was born.
	// Datatype: “Max70Text”
	// Required
	PlaceOfBirth         string   `protobuf:"bytes,2,opt,name=place_of_birth,json=placeOfBirth,proto3" json:"place_of_birth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DateAndPlaceOfBirth) Reset()         { *m = DateAndPlaceOfBirth{} }
func (m *DateAndPlaceOfBirth) String() string { return proto.CompactTextString(m) }
func (*DateAndPlaceOfBirth) ProtoMessage()    {}
func (*DateAndPlaceOfBirth) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{6}
}

func (m *DateAndPlaceOfBirth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DateAndPlaceOfBirth.Unmarshal(m, b)
}
func (m *DateAndPlaceOfBirth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DateAndPlaceOfBirth.Marshal(b, m, deterministic)
}
func (m *DateAndPlaceOfBirth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateAndPlaceOfBirth.Merge(m, src)
}
func (m *DateAndPlaceOfBirth) XXX_Size() int {
	return xxx_messageInfo_DateAndPlaceOfBirth.Size(m)
}
func (m *DateAndPlaceOfBirth) XXX_DiscardUnknown() {
	xxx_messageInfo_DateAndPlaceOfBirth.DiscardUnknown(m)
}

var xxx_messageInfo_DateAndPlaceOfBirth proto.InternalMessageInfo

func (m *DateAndPlaceOfBirth) GetDateOfBirth() string {
	if m != nil {
		return m.DateOfBirth
	}
	return ""
}

func (m *DateAndPlaceOfBirth) GetPlaceOfBirth() string {
	if m != nil {
		return m.PlaceOfBirth
	}
	return ""
}

// Constraint: ValidNationalIdentifierLegalPerson
// A legal person must have a value for nationalIdentifierType of either ‘RAID’ or
// ‘MISC’ or ‘LEIX’ or ‘TXID’.
// Constraint: CompleteNationalIdentifierLegalPerson
// A LegalPerson must not have a value for countryOfIssue and must have a value for the
// element RegistrationAuthority if the value for nationalIdentifierType is not ‘LEIX’
// Constraint: ValidLEI
// A LegalPerson with a nationalIdentifierType of ‘LEIX’ must have a value for the
// element nationalIdentifier that adheres to the convention as stated in datatype
// ‘LEIText’.
type NationalIdentification struct {
	// Definition: An identifier issued by an appropriate issuing authority.
	// Constraint: ValidLEI
	// Datatype: “Max35Text”
	// Required
	NationalIdentifier string `protobuf:"bytes,1,opt,name=national_identifier,json=nationalIdentifier,proto3" json:"national_identifier,omitempty"`
	// Definition: Specifies the type of identifier specified.
	// Required
	NationalIdentifierType NationalIdentifierTypeCode `protobuf:"varint,2,opt,name=national_identifier_type,json=nationalIdentifierType,proto3,enum=ivms101.NationalIdentifierTypeCode" json:"national_identifier_type,omitempty"`
	// Definition: Country of the issuing authority.
	// Datatype: “CountryCode”
	// Optional
	CountryOfIssue string `protobuf:"bytes,3,opt,name=country_of_issue,json=countryOfIssue,proto3" json:"country_of_issue,omitempty"`
	// Definition: A code specifying the registration authority.
	// Constraint: The value used for the applicable element must be present on the
	// GLEIF Registration Authorities List.
	// Datatype: “RegistrationAuthority”
	// Optional
	RegistrationAuthority string   `protobuf:"bytes,4,opt,name=registration_authority,json=registrationAuthority,proto3" json:"registration_authority,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *NationalIdentification) Reset()         { *m = NationalIdentification{} }
func (m *NationalIdentification) String() string { return proto.CompactTextString(m) }
func (*NationalIdentification) ProtoMessage()    {}
func (*NationalIdentification) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{7}
}

func (m *NationalIdentification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NationalIdentification.Unmarshal(m, b)
}
func (m *NationalIdentification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NationalIdentification.Marshal(b, m, deterministic)
}
func (m *NationalIdentification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NationalIdentification.Merge(m, src)
}
func (m *NationalIdentification) XXX_Size() int {
	return xxx_messageInfo_NationalIdentification.Size(m)
}
func (m *NationalIdentification) XXX_DiscardUnknown() {
	xxx_messageInfo_NationalIdentification.DiscardUnknown(m)
}

var xxx_messageInfo_NationalIdentification proto.InternalMessageInfo

func (m *NationalIdentification) GetNationalIdentifier() string {
	if m != nil {
		return m.NationalIdentifier
	}
	return ""
}

func (m *NationalIdentification) GetNationalIdentifierType() NationalIdentifierTypeCode {
	if m != nil {
		return m.NationalIdentifierType
	}
	return NationalIdentifierTypeCode_NATIONAL_IDENTIFIER_TYPE_CODE_ARNU
}

func (m *NationalIdentification) GetCountryOfIssue() string {
	if m != nil {
		return m.CountryOfIssue
	}
	return ""
}

func (m *NationalIdentification) GetRegistrationAuthority() string {
	if m != nil {
		return m.RegistrationAuthority
	}
	return ""
}

// Definition: refers to any entity other than a natural person that can establish a
// permanent customer relationship with an affected entity or otherwise own property.
// This can include companies, bodies corporate, foundations, anstalt, partnerships, or
// associations and other relevantly similar entities.
// Constraint: OriginatorInformationLegalPerson
// If the originator is a LegalPerson either geographicAddress (with an addressType
// value of ‘GEOG’) and/or nationalIdentification and/or customerNumber is required.
type LegalPerson struct {
	// Definition: The name of the legal person.
	// Constraint: LegalNamePresentLegalPerson
	// At least one occurrence of legalPersonNameIdentifier must have the value ‘LEGL’
	// specified in the element legalPersonNameIdentifierType.
	Name *LegalPersonName `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Definition: The address of the legal person.
	// Zero or more
	GeographicAddresses []*Address `protobuf:"bytes,2,rep,name=geographic_addresses,json=geographicAddresses,proto3" json:"geographic_addresses,omitempty"`
	// Definition: The unique identification number applied by the VASP to customer.
	// NOTE The specification has a descrepency in that 5.2.9.3.3 specifies an element
	// name as "customerNumber", while the table in 5.2.9.1 calls that element
	// "customerIdentification"
	// Datatype: “Max50Text”
	// Optional
	CustomerNumber string `protobuf:"bytes,3,opt,name=customer_number,json=customerNumber,proto3" json:"customer_number,omitempty"`
	// Definition: A distinct identifier used by governments of countries to uniquely
	// identify a natural or legal person.
	// Optional
	NationalIdentification *NationalIdentification `protobuf:"bytes,4,opt,name=national_identification,json=nationalIdentification,proto3" json:"national_identification,omitempty"`
	// Definition: The country in which the legal person is registered.
	// Constraint: The value used for the field country must be present on the
	// ISO-3166-1 alpha-2 codes or the value XX.
	// Datatype: “CountryCode”
	// Optional
	CountryOfRegistration string   `protobuf:"bytes,5,opt,name=country_of_registration,json=countryOfRegistration,proto3" json:"country_of_registration,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *LegalPerson) Reset()         { *m = LegalPerson{} }
func (m *LegalPerson) String() string { return proto.CompactTextString(m) }
func (*LegalPerson) ProtoMessage()    {}
func (*LegalPerson) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{8}
}

func (m *LegalPerson) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LegalPerson.Unmarshal(m, b)
}
func (m *LegalPerson) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LegalPerson.Marshal(b, m, deterministic)
}
func (m *LegalPerson) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegalPerson.Merge(m, src)
}
func (m *LegalPerson) XXX_Size() int {
	return xxx_messageInfo_LegalPerson.Size(m)
}
func (m *LegalPerson) XXX_DiscardUnknown() {
	xxx_messageInfo_LegalPerson.DiscardUnknown(m)
}

var xxx_messageInfo_LegalPerson proto.InternalMessageInfo

func (m *LegalPerson) GetName() *LegalPersonName {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *LegalPerson) GetGeographicAddresses() []*Address {
	if m != nil {
		return m.GeographicAddresses
	}
	return nil
}

func (m *LegalPerson) GetCustomerNumber() string {
	if m != nil {
		return m.CustomerNumber
	}
	return ""
}

func (m *LegalPerson) GetNationalIdentification() *NationalIdentification {
	if m != nil {
		return m.NationalIdentification
	}
	return nil
}

func (m *LegalPerson) GetCountryOfRegistration() string {
	if m != nil {
		return m.CountryOfRegistration
	}
	return ""
}

type LegalPersonName struct {
	// Definition: The name and type of name by which the legal person is known.
	// Constraint: LegalNamePresent
	// At least one occurrence of legalPersonNameIdentifier must have the value
	// ‘LEGL’ specified in the element legalPersonNameIdentifierType.
	// One or more
	NameIdentifiers []*LegalPersonNameId `protobuf:"bytes,1,rep,name=name_identifiers,json=nameIdentifiers,proto3" json:"name_identifiers,omitempty"`
	// Definition: The name and type of name by which the legal person is known using
	// local characters.
	// Zero or more
	LocalNameIdentifiers []*LocalLegalPersonNameId `protobuf:"bytes,2,rep,name=local_name_identifiers,json=localNameIdentifiers,proto3" json:"local_name_identifiers,omitempty"`
	// Definition: The name and type of name by which the legal person is known using
	// local characters.
	// Zero or more
	PhoneticNameIdentifiers []*LocalLegalPersonNameId `protobuf:"bytes,3,rep,name=phonetic_name_identifiers,json=phoneticNameIdentifiers,proto3" json:"phonetic_name_identifiers,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                  `json:"-"`
	XXX_unrecognized        []byte                    `json:"-"`
	XXX_sizecache           int32                     `json:"-"`
}

func (m *LegalPersonName) Reset()         { *m = LegalPersonName{} }
func (m *LegalPersonName) String() string { return proto.CompactTextString(m) }
func (*LegalPersonName) ProtoMessage()    {}
func (*LegalPersonName) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{9}
}

func (m *LegalPersonName) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LegalPersonName.Unmarshal(m, b)
}
func (m *LegalPersonName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LegalPersonName.Marshal(b, m, deterministic)
}
func (m *LegalPersonName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegalPersonName.Merge(m, src)
}
func (m *LegalPersonName) XXX_Size() int {
	return xxx_messageInfo_LegalPersonName.Size(m)
}
func (m *LegalPersonName) XXX_DiscardUnknown() {
	xxx_messageInfo_LegalPersonName.DiscardUnknown(m)
}

var xxx_messageInfo_LegalPersonName proto.InternalMessageInfo

func (m *LegalPersonName) GetNameIdentifiers() []*LegalPersonNameId {
	if m != nil {
		return m.NameIdentifiers
	}
	return nil
}

func (m *LegalPersonName) GetLocalNameIdentifiers() []*LocalLegalPersonNameId {
	if m != nil {
		return m.LocalNameIdentifiers
	}
	return nil
}

func (m *LegalPersonName) GetPhoneticNameIdentifiers() []*LocalLegalPersonNameId {
	if m != nil {
		return m.PhoneticNameIdentifiers
	}
	return nil
}

type LegalPersonNameId struct {
	// Definition: Name by which the legal person is known.
	// Datatype: “Max100Text”
	// Required
	LegalPersonName string `protobuf:"bytes,1,opt,name=legal_person_name,json=legalPersonName,proto3" json:"legal_person_name,omitempty"`
	// Definition: The nature of the name specified.
	// Required
	LegalPersonNameIdentifierType LegalPersonNameTypeCode `protobuf:"varint,2,opt,name=legal_person_name_identifier_type,json=legalPersonNameIdentifierType,proto3,enum=ivms101.LegalPersonNameTypeCode" json:"legal_person_name_identifier_type,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                `json:"-"`
	XXX_unrecognized              []byte                  `json:"-"`
	XXX_sizecache                 int32                   `json:"-"`
}

func (m *LegalPersonNameId) Reset()         { *m = LegalPersonNameId{} }
func (m *LegalPersonNameId) String() string { return proto.CompactTextString(m) }
func (*LegalPersonNameId) ProtoMessage()    {}
func (*LegalPersonNameId) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{10}
}

func (m *LegalPersonNameId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LegalPersonNameId.Unmarshal(m, b)
}
func (m *LegalPersonNameId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LegalPersonNameId.Marshal(b, m, deterministic)
}
func (m *LegalPersonNameId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegalPersonNameId.Merge(m, src)
}
func (m *LegalPersonNameId) XXX_Size() int {
	return xxx_messageInfo_LegalPersonNameId.Size(m)
}
func (m *LegalPersonNameId) XXX_DiscardUnknown() {
	xxx_messageInfo_LegalPersonNameId.DiscardUnknown(m)
}

var xxx_messageInfo_LegalPersonNameId proto.InternalMessageInfo

func (m *LegalPersonNameId) GetLegalPersonName() string {
	if m != nil {
		return m.LegalPersonName
	}
	return ""
}

func (m *LegalPersonNameId) GetLegalPersonNameIdentifierType() LegalPersonNameTypeCode {
	if m != nil {
		return m.LegalPersonNameIdentifierType
	}
	return LegalPersonNameTypeCode_LEGAL_PERSON_NAME_TYPE_CODE_LEGL
}

type LocalLegalPersonNameId struct {
	// Definition: Name by which the legal person is known.
	// Datatype: "LocalMax100Text"
	// Required
	LegalPersonName string `protobuf:"bytes,1,opt,name=legal_person_name,json=legalPersonName,proto3" json:"legal_person_name,omitempty"`
	// Definition: The nature of the name specified.
	// Required
	LegalPersonNameIdentifierType LegalPersonNameTypeCode `protobuf:"varint,2,opt,name=legal_person_name_identifier_type,json=legalPersonNameIdentifierType,proto3,enum=ivms101.LegalPersonNameTypeCode" json:"legal_person_name_identifier_type,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                `json:"-"`
	XXX_unrecognized              []byte                  `json:"-"`
	XXX_sizecache                 int32                   `json:"-"`
}

func (m *LocalLegalPersonNameId) Reset()         { *m = LocalLegalPersonNameId{} }
func (m *LocalLegalPersonNameId) String() string { return proto.CompactTextString(m) }
func (*LocalLegalPersonNameId) ProtoMessage()    {}
func (*LocalLegalPersonNameId) Descriptor() ([]byte, []int) {
	return fileDescriptor_242a50d124d33d4e, []int{11}
}

func (m *LocalLegalPersonNameId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocalLegalPersonNameId.Unmarshal(m, b)
}
func (m *LocalLegalPersonNameId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocalLegalPersonNameId.Marshal(b, m, deterministic)
}
func (m *LocalLegalPersonNameId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalLegalPersonNameId.Merge(m, src)
}
func (m *LocalLegalPersonNameId) XXX_Size() int {
	return xxx_messageInfo_LocalLegalPersonNameId.Size(m)
}
func (m *LocalLegalPersonNameId) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalLegalPersonNameId.DiscardUnknown(m)
}

var xxx_messageInfo_LocalLegalPersonNameId proto.InternalMessageInfo

func (m *LocalLegalPersonNameId) GetLegalPersonName() string {
	if m != nil {
		return m.LegalPersonName
	}
	return ""
}

func (m *LocalLegalPersonNameId) GetLegalPersonNameIdentifierType() LegalPersonNameTypeCode {
	if m != nil {
		return m.LegalPersonNameIdentifierType
	}
	return LegalPersonNameTypeCode_LEGAL_PERSON_NAME_TYPE_CODE_LEGL
}

func init() {
	proto.RegisterType((*Person)(nil), "ivms101.Person")
	proto.RegisterType((*NaturalPerson)(nil), "ivms101.NaturalPerson")
	proto.RegisterType((*NaturalPersonName)(nil), "ivms101.NaturalPersonName")
	proto.RegisterType((*NaturalPersonNameId)(nil), "ivms101.NaturalPersonNameId")
	proto.RegisterType((*LocalNaturalPersonNameId)(nil), "ivms101.LocalNaturalPersonNameId")
	proto.RegisterType((*Address)(nil), "ivms101.Address")
	proto.RegisterType((*DateAndPlaceOfBirth)(nil), "ivms101.DateAndPlaceOfBirth")
	proto.RegisterType((*NationalIdentification)(nil), "ivms101.NationalIdentification")
	proto.RegisterType((*LegalPerson)(nil), "ivms101.LegalPerson")
	proto.RegisterType((*LegalPersonName)(nil), "ivms101.LegalPersonName")
	proto.RegisterType((*LegalPersonNameId)(nil), "ivms101.LegalPersonNameId")
	proto.RegisterType((*LocalLegalPersonNameId)(nil), "ivms101.LocalLegalPersonNameId")
}

func init() { proto.RegisterFile("ivms101.proto", fileDescriptor_242a50d124d33d4e) }

var fileDescriptor_242a50d124d33d4e = []byte{
	// 1039 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x5d, 0x6f, 0xe3, 0x44,
	0x17, 0x7e, 0x9d, 0x74, 0xdb, 0xe6, 0xe4, 0xb3, 0x93, 0x6c, 0xe2, 0xed, 0xbb, 0xd0, 0xd4, 0x05,
	0x6d, 0x84, 0x96, 0xb2, 0x2d, 0x02, 0x84, 0xb8, 0x40, 0xed, 0x16, 0x41, 0xa5, 0xaa, 0xbb, 0x32,
	0x8b, 0x40, 0xa0, 0x95, 0xe5, 0xd8, 0x93, 0xd4, 0xc8, 0x99, 0xb1, 0xc6, 0xe3, 0x65, 0xf3, 0x13,
	0x90, 0x10, 0x57, 0xdc, 0xf2, 0x0b, 0xb8, 0xe1, 0x1e, 0xf1, 0x13, 0xb8, 0xe1, 0x17, 0xa1, 0xf9,
	0xf0, 0x47, 0x1c, 0x87, 0x22, 0xc1, 0x05, 0x5c, 0xb5, 0x73, 0x9e, 0xe7, 0x3c, 0x9e, 0x39, 0x73,
	0x3e, 0x26, 0xd0, 0x0e, 0x5e, 0x2c, 0xe2, 0x93, 0x47, 0x27, 0xc7, 0x11, 0xa3, 0x9c, 0xa2, 0x1d,
	0xbd, 0xdc, 0x07, 0x4c, 0x92, 0x85, 0x32, 0x5a, 0xdf, 0x1b, 0xb0, 0xfd, 0x14, 0xb3, 0x98, 0x12,
	0xf4, 0x21, 0x74, 0x88, 0xcb, 0x13, 0xe6, 0x86, 0x4e, 0x24, 0x2d, 0xa6, 0x31, 0x36, 0x26, 0xcd,
	0xd3, 0xe1, 0x71, 0xaa, 0x73, 0xad, 0x60, 0xc5, 0xff, 0xe4, 0x7f, 0x76, 0x9b, 0x14, 0x0d, 0xe8,
	0x7d, 0x68, 0x85, 0x78, 0x9e, 0xbb, 0xd7, 0xa4, 0xfb, 0x20, 0x73, 0xbf, 0x12, 0x60, 0xe6, 0xdc,
	0x0c, 0xf3, 0xe5, 0xf9, 0x2e, 0x6c, 0x2b, 0x27, 0xeb, 0xc7, 0x3a, 0xb4, 0x57, 0xbe, 0x83, 0x8e,
	0x61, 0x8b, 0xb8, 0x0b, 0xac, 0x77, 0xb3, 0x5f, 0xbd, 0x9b, 0x6b, 0x77, 0x81, 0x6d, 0xc9, 0x43,
	0x8f, 0x61, 0x30, 0xc7, 0x74, 0xce, 0xdc, 0xe8, 0x26, 0xf0, 0x1c, 0xd7, 0xf7, 0x19, 0x8e, 0x63,
	0x1c, 0x9b, 0xb5, 0x71, 0x7d, 0xd2, 0x3c, 0xed, 0x65, 0xfe, 0x67, 0x0a, 0xb1, 0xfb, 0x39, 0xfb,
	0x2c, 0x25, 0xa3, 0x2f, 0x60, 0x44, 0x5c, 0x1e, 0x50, 0xe2, 0x86, 0x4e, 0xe0, 0x63, 0xc2, 0x83,
	0x59, 0xe0, 0x49, 0x83, 0x59, 0x97, 0xfb, 0x38, 0x28, 0xee, 0x43, 0xf2, 0x2e, 0x57, 0x68, 0xf6,
	0x90, 0x54, 0xda, 0xd1, 0x7b, 0x30, 0xf2, 0x92, 0x98, 0xd3, 0x05, 0x66, 0x65, 0xe5, 0xad, 0xb1,
	0x31, 0x69, 0xd8, 0xc3, 0x14, 0x2e, 0x39, 0xda, 0x30, 0xf2, 0x5d, 0x8e, 0x1d, 0x97, 0xf8, 0x4e,
	0x14, 0xba, 0x1e, 0x76, 0xe8, 0xcc, 0x99, 0x06, 0x8c, 0xdf, 0x98, 0x77, 0xe4, 0x96, 0xee, 0x67,
	0x5b, 0xba, 0x70, 0x39, 0x3e, 0x23, 0xfe, 0x53, 0xc1, 0x7a, 0x32, 0x3b, 0x17, 0x1c, 0xbb, 0xef,
	0xaf, 0x1b, 0xd1, 0x23, 0x18, 0x78, 0x34, 0x21, 0x9c, 0x2d, 0x85, 0x18, 0xc3, 0xb1, 0xd8, 0x91,
	0x87, 0xcd, 0x6d, 0xb9, 0x13, 0xa4, 0xb1, 0x27, 0x33, 0x3b, 0x45, 0xac, 0x1f, 0x6a, 0xb0, 0xb7,
	0x16, 0x79, 0xf4, 0x31, 0xf4, 0x44, 0xec, 0xb3, 0x03, 0x61, 0x16, 0x9b, 0x86, 0x8c, 0xf7, 0xfd,
	0xcd, 0xf7, 0x75, 0xe9, 0xdb, 0x5d, 0x22, 0xff, 0x66, 0x4e, 0xe8, 0x73, 0x18, 0x86, 0xd4, 0x73,
	0x43, 0x67, 0x4d, 0x4e, 0x5d, 0xdf, 0x61, 0x9e, 0x4d, 0x82, 0x56, 0xa5, 0x39, 0x08, 0x15, 0xb2,
	0x2a, 0xfc, 0x1c, 0xee, 0x45, 0x37, 0x94, 0x60, 0x1e, 0x78, 0xeb, 0xda, 0xf5, 0xbf, 0xaa, 0x3d,
	0x4a, 0x35, 0x4a, 0xf2, 0xd6, 0x6f, 0x06, 0xf4, 0x2b, 0x1c, 0xd0, 0x9b, 0x80, 0x22, 0x16, 0x2c,
	0x5c, 0xb6, 0x2c, 0x7c, 0x50, 0xa6, 0x72, 0xc3, 0xde, 0xd3, 0x48, 0xae, 0x83, 0x4e, 0x60, 0x10,
	0x63, 0x8f, 0x12, 0xbf, 0xe4, 0x50, 0x93, 0x0e, 0xfd, 0x0c, 0x2b, 0xb8, 0x3c, 0x83, 0x41, 0xe9,
	0x3c, 0x0e, 0x5f, 0x46, 0x58, 0xa6, 0x69, 0xe7, 0xd4, 0xda, 0x1c, 0xfe, 0x67, 0xcb, 0x08, 0x3f,
	0xa6, 0x3e, 0xb6, 0xd1, 0xea, 0x25, 0x08, 0xbb, 0xf5, 0xbb, 0x01, 0xe6, 0xa6, 0x28, 0xfc, 0x67,
	0x0f, 0xf5, 0xeb, 0x16, 0xec, 0xe8, 0x12, 0x47, 0x1f, 0x40, 0x4b, 0xb7, 0x06, 0xa5, 0x6c, 0x48,
	0x65, 0xb3, 0xdc, 0x1d, 0x32, 0xbd, 0xa6, 0x9b, 0x1b, 0xd0, 0xab, 0x00, 0x3e, 0x8e, 0x5c, 0xc6,
	0x17, 0x98, 0x70, 0x7d, 0x8e, 0x82, 0x05, 0xbd, 0x0e, 0x9d, 0x38, 0x99, 0x3a, 0x05, 0x4e, 0x5d,
	0x72, 0xda, 0x71, 0x32, 0xbd, 0xc8, 0x69, 0x07, 0xd0, 0x8c, 0x39, 0xc3, 0x98, 0xcb, 0x8c, 0xd4,
	0xe5, 0x0f, 0xca, 0x24, 0xcb, 0xea, 0x01, 0x74, 0xa7, 0x49, 0x10, 0xfa, 0x01, 0x99, 0x3b, 0x24,
	0x59, 0x4c, 0x31, 0x93, 0xa5, 0xde, 0xb0, 0x3b, 0xa9, 0xf9, 0x5a, 0x5a, 0xd1, 0x11, 0xb4, 0x73,
	0xa2, 0xd0, 0x52, 0x05, 0xdc, 0xca, 0x68, 0x42, 0x6d, 0x00, 0x77, 0x66, 0x21, 0xa5, 0xcc, 0xdc,
	0x91, 0xa0, 0x5a, 0xa0, 0x7b, 0xb0, 0x1b, 0xd1, 0x98, 0x3b, 0x53, 0xfa, 0xd2, 0xdc, 0x95, 0xc0,
	0x8e, 0x58, 0x9f, 0xd3, 0x97, 0x08, 0xc1, 0x16, 0xa3, 0x74, 0x61, 0x36, 0xa4, 0x59, 0xfe, 0x8f,
	0xfe, 0x0f, 0x0d, 0x49, 0xf7, 0xa8, 0x8f, 0x4d, 0x90, 0x80, 0xf4, 0x17, 0x41, 0x12, 0x20, 0xa7,
	0xdf, 0x10, 0xb5, 0x85, 0xa6, 0x02, 0x85, 0x41, 0x7e, 0xfe, 0x21, 0x20, 0x09, 0x8a, 0xf2, 0x14,
	0x0d, 0x4d, 0xb1, 0x5a, 0x92, 0xd5, 0x13, 0xc8, 0x95, 0x06, 0x24, 0xfb, 0x08, 0xda, 0x7e, 0x10,
	0x73, 0x16, 0x78, 0x3a, 0x3a, 0x6d, 0x75, 0xa2, 0xd4, 0x28, 0x49, 0x85, 0xf6, 0x25, 0xe3, 0x1d,
	0xbc, 0x08, 0x62, 0xd1, 0x48, 0x3b, 0x2b, 0xed, 0xeb, 0xd3, 0x64, 0x7a, 0xa1, 0x11, 0x74, 0x98,
	0x5f, 0x7b, 0x18, 0x10, 0x6c, 0x76, 0xc7, 0xf5, 0x49, 0x23, 0xbb, 0xdc, 0xab, 0x80, 0x60, 0x64,
	0xc2, 0x8e, 0x76, 0x34, 0x7b, 0x2a, 0x1e, 0x7a, 0x69, 0x39, 0xd0, 0xaf, 0xe8, 0xac, 0xc8, 0x82,
	0xb6, 0x6c, 0xcc, 0x59, 0x3b, 0x56, 0x95, 0xd0, 0x14, 0xc6, 0x94, 0xf3, 0x1a, 0x74, 0x4a, 0x3d,
	0x5b, 0x65, 0x4d, 0x2b, 0x2a, 0x28, 0x59, 0xdf, 0xd6, 0x60, 0x58, 0x3d, 0x4e, 0xd0, 0x5b, 0xd0,
	0x5f, 0x1b, 0x48, 0x59, 0xd1, 0xa1, 0xf2, 0xac, 0xc1, 0x0c, 0x3d, 0x07, 0xb3, 0xc2, 0x41, 0x25,
	0x7b, 0x4d, 0x26, 0xfb, 0xd1, 0xc6, 0x11, 0xa6, 0xea, 0x45, 0xe6, 0xfd, 0x90, 0x54, 0x62, 0x68,
	0x02, 0xbd, 0xc2, 0xe4, 0x08, 0xe2, 0x38, 0xc1, 0x3a, 0xc9, 0x3b, 0xd9, 0xd4, 0xb8, 0x14, 0x56,
	0xf4, 0x0e, 0x0c, 0x19, 0x9e, 0x8b, 0x6b, 0x53, 0xd7, 0xee, 0x26, 0xfc, 0x86, 0xb2, 0x80, 0x2f,
	0x75, 0xc2, 0xdf, 0x2d, 0xa2, 0x67, 0x29, 0x68, 0xfd, 0x52, 0x83, 0x66, 0xe1, 0xc5, 0x80, 0x1e,
	0xae, 0x3c, 0x03, 0xcc, 0xaa, 0x57, 0xc5, 0x3f, 0xfd, 0x08, 0x78, 0x00, 0xdd, 0x6c, 0x54, 0xeb,
	0xf2, 0x4b, 0x8f, 0xa8, 0xcd, 0xba, 0xfc, 0xfe, 0xe4, 0xb5, 0xb0, 0xf5, 0xf7, 0x5e, 0x0b, 0xef,
	0xc2, 0x68, 0x65, 0x40, 0xe7, 0x91, 0xd2, 0x9d, 0xe0, 0x6e, 0x61, 0x46, 0xe7, 0xa0, 0xf5, 0x5d,
	0x0d, 0xba, 0xa5, 0xc8, 0xa0, 0x8f, 0x36, 0x0e, 0xe9, 0xfd, 0x4d, 0xd1, 0xac, 0x1a, 0xd1, 0x9f,
	0xdd, 0x32, 0xa2, 0x0f, 0x56, 0xc7, 0xe8, 0xba, 0x62, 0xf5, 0x80, 0xfe, 0xea, 0xf6, 0x01, 0x7d,
	0xab, 0xf2, 0xc6, 0xf1, 0xfc, 0x93, 0x01, 0x7b, 0x6b, 0x74, 0xf4, 0x06, 0xec, 0x15, 0x1f, 0xac,
	0x4e, 0x96, 0x5f, 0x0d, 0xbb, 0x1b, 0x96, 0x82, 0xf7, 0x35, 0x1c, 0xae, 0x71, 0x37, 0xd4, 0xd5,
	0x78, 0x53, 0x34, 0xb3, 0xa2, 0x7a, 0x25, 0x2c, 0xef, 0x65, 0x65, 0x4e, 0xfd, 0x6c, 0xc0, 0xb0,
	0xfa, 0x84, 0xff, 0xd6, 0x2d, 0x9f, 0x37, 0xbe, 0x4c, 0x7f, 0x5e, 0x4c, 0xb7, 0xe5, 0x2f, 0x8b,
	0xb7, 0xff, 0x08, 0x00, 0x00, 0xff, 0xff, 0x02, 0x74, 0x52, 0xeb, 0x7f, 0x0c, 0x00, 0x00,
}
