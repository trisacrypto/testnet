// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1alpha1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// TRISANetworkClient is the client API for TRISANetwork service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TRISANetworkClient interface {
	// To conduct an information exchange prior to a virtual asset transaction, an
	// originating VASP will send an encrypted transaction envelope to the beneficiary
	// VASP containing a unique ID for the transaction, the encrypted transaction bundle,
	// and metadata associated with the transaction cipher. In response, the beneficiary
	// will validate the transaction request, then return the beneficiary's transaction
	// information using the same unique transaction ID. The TRISANetwork provides both
	// a unary RPC for simple, single transactions and a transaction stream for high
	// throughput transaction workloads.
	Transfer(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*Transaction, error)
	TransactionStream(ctx context.Context, opts ...grpc.CallOption) (TRISANetwork_TransactionStreamClient, error)
	// Address confirmation allows an originator VASP to establish that a beneficiary
	// VASP has control of a crypto wallet address, prior to sending transaction
	// information with sensitive PII data.
	ConfirmAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*AddressConfirmation, error)
	// The encrypted transaction envelope uses asymmetric (public/private) encryption to
	// exchange a symmetric key and signature for the transaction blob. To facilitate
	// transaction signatures, VASPs must be able to exchange public signing keys if
	// they have not already obtained them from the directory service.
	KeyExchange(ctx context.Context, in *SigningKey, opts ...grpc.CallOption) (*SigningKey, error)
}

type tRISANetworkClient struct {
	cc grpc.ClientConnInterface
}

func NewTRISANetworkClient(cc grpc.ClientConnInterface) TRISANetworkClient {
	return &tRISANetworkClient{cc}
}

func (c *tRISANetworkClient) Transfer(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/trisa.protocol.v1alpha1.TRISANetwork/Transfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tRISANetworkClient) TransactionStream(ctx context.Context, opts ...grpc.CallOption) (TRISANetwork_TransactionStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TRISANetwork_serviceDesc.Streams[0], "/trisa.protocol.v1alpha1.TRISANetwork/TransactionStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &tRISANetworkTransactionStreamClient{stream}
	return x, nil
}

type TRISANetwork_TransactionStreamClient interface {
	Send(*Transaction) error
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type tRISANetworkTransactionStreamClient struct {
	grpc.ClientStream
}

func (x *tRISANetworkTransactionStreamClient) Send(m *Transaction) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tRISANetworkTransactionStreamClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tRISANetworkClient) ConfirmAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*AddressConfirmation, error) {
	out := new(AddressConfirmation)
	err := c.cc.Invoke(ctx, "/trisa.protocol.v1alpha1.TRISANetwork/ConfirmAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tRISANetworkClient) KeyExchange(ctx context.Context, in *SigningKey, opts ...grpc.CallOption) (*SigningKey, error) {
	out := new(SigningKey)
	err := c.cc.Invoke(ctx, "/trisa.protocol.v1alpha1.TRISANetwork/KeyExchange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TRISANetworkServer is the server API for TRISANetwork service.
// All implementations must embed UnimplementedTRISANetworkServer
// for forward compatibility
type TRISANetworkServer interface {
	// To conduct an information exchange prior to a virtual asset transaction, an
	// originating VASP will send an encrypted transaction envelope to the beneficiary
	// VASP containing a unique ID for the transaction, the encrypted transaction bundle,
	// and metadata associated with the transaction cipher. In response, the beneficiary
	// will validate the transaction request, then return the beneficiary's transaction
	// information using the same unique transaction ID. The TRISANetwork provides both
	// a unary RPC for simple, single transactions and a transaction stream for high
	// throughput transaction workloads.
	Transfer(context.Context, *Transaction) (*Transaction, error)
	TransactionStream(TRISANetwork_TransactionStreamServer) error
	// Address confirmation allows an originator VASP to establish that a beneficiary
	// VASP has control of a crypto wallet address, prior to sending transaction
	// information with sensitive PII data.
	ConfirmAddress(context.Context, *Address) (*AddressConfirmation, error)
	// The encrypted transaction envelope uses asymmetric (public/private) encryption to
	// exchange a symmetric key and signature for the transaction blob. To facilitate
	// transaction signatures, VASPs must be able to exchange public signing keys if
	// they have not already obtained them from the directory service.
	KeyExchange(context.Context, *SigningKey) (*SigningKey, error)
	mustEmbedUnimplementedTRISANetworkServer()
}

// UnimplementedTRISANetworkServer must be embedded to have forward compatible implementations.
type UnimplementedTRISANetworkServer struct {
}

func (UnimplementedTRISANetworkServer) Transfer(context.Context, *Transaction) (*Transaction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedTRISANetworkServer) TransactionStream(TRISANetwork_TransactionStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method TransactionStream not implemented")
}
func (UnimplementedTRISANetworkServer) ConfirmAddress(context.Context, *Address) (*AddressConfirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmAddress not implemented")
}
func (UnimplementedTRISANetworkServer) KeyExchange(context.Context, *SigningKey) (*SigningKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyExchange not implemented")
}
func (UnimplementedTRISANetworkServer) mustEmbedUnimplementedTRISANetworkServer() {}

// UnsafeTRISANetworkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TRISANetworkServer will
// result in compilation errors.
type UnsafeTRISANetworkServer interface {
	mustEmbedUnimplementedTRISANetworkServer()
}

func RegisterTRISANetworkServer(s grpc.ServiceRegistrar, srv TRISANetworkServer) {
	s.RegisterService(&_TRISANetwork_serviceDesc, srv)
}

func _TRISANetwork_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISANetworkServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trisa.protocol.v1alpha1.TRISANetwork/Transfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISANetworkServer).Transfer(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _TRISANetwork_TransactionStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TRISANetworkServer).TransactionStream(&tRISANetworkTransactionStreamServer{stream})
}

type TRISANetwork_TransactionStreamServer interface {
	Send(*Transaction) error
	Recv() (*Transaction, error)
	grpc.ServerStream
}

type tRISANetworkTransactionStreamServer struct {
	grpc.ServerStream
}

func (x *tRISANetworkTransactionStreamServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tRISANetworkTransactionStreamServer) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TRISANetwork_ConfirmAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISANetworkServer).ConfirmAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trisa.protocol.v1alpha1.TRISANetwork/ConfirmAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISANetworkServer).ConfirmAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _TRISANetwork_KeyExchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SigningKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISANetworkServer).KeyExchange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trisa.protocol.v1alpha1.TRISANetwork/KeyExchange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISANetworkServer).KeyExchange(ctx, req.(*SigningKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _TRISANetwork_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trisa.protocol.v1alpha1.TRISANetwork",
	HandlerType: (*TRISANetworkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Transfer",
			Handler:    _TRISANetwork_Transfer_Handler,
		},
		{
			MethodName: "ConfirmAddress",
			Handler:    _TRISANetwork_ConfirmAddress_Handler,
		},
		{
			MethodName: "KeyExchange",
			Handler:    _TRISANetwork_KeyExchange_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TransactionStream",
			Handler:       _TRISANetwork_TransactionStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "trisa/protocol/v1alpha1/api.proto",
}

// TRISADiscoveryClient is the client API for TRISADiscovery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TRISADiscoveryClient interface {
	Handshake(ctx context.Context, in *VASPLookup, opts ...grpc.CallOption) (*Connection, error)
}

type tRISADiscoveryClient struct {
	cc grpc.ClientConnInterface
}

func NewTRISADiscoveryClient(cc grpc.ClientConnInterface) TRISADiscoveryClient {
	return &tRISADiscoveryClient{cc}
}

func (c *tRISADiscoveryClient) Handshake(ctx context.Context, in *VASPLookup, opts ...grpc.CallOption) (*Connection, error) {
	out := new(Connection)
	err := c.cc.Invoke(ctx, "/trisa.protocol.v1alpha1.TRISADiscovery/Handshake", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TRISADiscoveryServer is the server API for TRISADiscovery service.
// All implementations must embed UnimplementedTRISADiscoveryServer
// for forward compatibility
type TRISADiscoveryServer interface {
	Handshake(context.Context, *VASPLookup) (*Connection, error)
	mustEmbedUnimplementedTRISADiscoveryServer()
}

// UnimplementedTRISADiscoveryServer must be embedded to have forward compatible implementations.
type UnimplementedTRISADiscoveryServer struct {
}

func (UnimplementedTRISADiscoveryServer) Handshake(context.Context, *VASPLookup) (*Connection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handshake not implemented")
}
func (UnimplementedTRISADiscoveryServer) mustEmbedUnimplementedTRISADiscoveryServer() {}

// UnsafeTRISADiscoveryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TRISADiscoveryServer will
// result in compilation errors.
type UnsafeTRISADiscoveryServer interface {
	mustEmbedUnimplementedTRISADiscoveryServer()
}

func RegisterTRISADiscoveryServer(s grpc.ServiceRegistrar, srv TRISADiscoveryServer) {
	s.RegisterService(&_TRISADiscovery_serviceDesc, srv)
}

func _TRISADiscovery_Handshake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VASPLookup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISADiscoveryServer).Handshake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trisa.protocol.v1alpha1.TRISADiscovery/Handshake",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISADiscoveryServer).Handshake(ctx, req.(*VASPLookup))
	}
	return interceptor(ctx, in, info, handler)
}

var _TRISADiscovery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trisa.protocol.v1alpha1.TRISADiscovery",
	HandlerType: (*TRISADiscoveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Handshake",
			Handler:    _TRISADiscovery_Handshake_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trisa/protocol/v1alpha1/api.proto",
}

// TRISAHealthClient is the client API for TRISAHealth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TRISAHealthClient interface {
	Status(ctx context.Context, in *HealthCheck, opts ...grpc.CallOption) (*ServiceState, error)
}

type tRISAHealthClient struct {
	cc grpc.ClientConnInterface
}

func NewTRISAHealthClient(cc grpc.ClientConnInterface) TRISAHealthClient {
	return &tRISAHealthClient{cc}
}

func (c *tRISAHealthClient) Status(ctx context.Context, in *HealthCheck, opts ...grpc.CallOption) (*ServiceState, error) {
	out := new(ServiceState)
	err := c.cc.Invoke(ctx, "/trisa.protocol.v1alpha1.TRISAHealth/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TRISAHealthServer is the server API for TRISAHealth service.
// All implementations must embed UnimplementedTRISAHealthServer
// for forward compatibility
type TRISAHealthServer interface {
	Status(context.Context, *HealthCheck) (*ServiceState, error)
	mustEmbedUnimplementedTRISAHealthServer()
}

// UnimplementedTRISAHealthServer must be embedded to have forward compatible implementations.
type UnimplementedTRISAHealthServer struct {
}

func (UnimplementedTRISAHealthServer) Status(context.Context, *HealthCheck) (*ServiceState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedTRISAHealthServer) mustEmbedUnimplementedTRISAHealthServer() {}

// UnsafeTRISAHealthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TRISAHealthServer will
// result in compilation errors.
type UnsafeTRISAHealthServer interface {
	mustEmbedUnimplementedTRISAHealthServer()
}

func RegisterTRISAHealthServer(s grpc.ServiceRegistrar, srv TRISAHealthServer) {
	s.RegisterService(&_TRISAHealth_serviceDesc, srv)
}

func _TRISAHealth_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISAHealthServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trisa.protocol.v1alpha1.TRISAHealth/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISAHealthServer).Status(ctx, req.(*HealthCheck))
	}
	return interceptor(ctx, in, info, handler)
}

var _TRISAHealth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trisa.protocol.v1alpha1.TRISAHealth",
	HandlerType: (*TRISAHealthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _TRISAHealth_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trisa/protocol/v1alpha1/api.proto",
}
